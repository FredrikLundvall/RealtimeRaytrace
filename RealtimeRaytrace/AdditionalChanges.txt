Up, Right and Backward are the positive directions in Matrix and Vector. Up is +Y, Right is +X and Backward is +Z
Down, Left and Forward are the negative directions in Matrix and Vector. Down is -Y, Left is -X and Forward is -Z

General guidelines
Focus on hiding the inner workings of the different parts for the caller. It's good if it's open and possible to change parts in the middle whether it's for speed or change the design. 
Eg. The raytracing should not know how the pixels are drawn. 
Do not care about the performance, optimization is at a much later stage (with a possible exception of threading issues, that can be good to still consider). 
Interfaces are great for keeping loose couplings in the code.
Don't forget the unit tests, they are great tools while developing.
Be aware of the garbage collections. Try to not create new objects. Reuse objects or use records.

Priority list
1. Now it is time to branch out and focus on an actual game concept:
   1 vs 1 battle game. 
   Side-viewed. 
   Inmovable camera.
   Simplistic characters.
   Physics from box2d library. 
   Make a thin z-layer, 1 - 10 voxels deep.

Known issues    
Find the first intersection with the ray/grid before starting the voxel traverse
CommandQueue may be the reason for the gc every ten seconds
Add possibility fo spheres to exist in multiple grids, it's only cube/sphere intersection that's missing

Suggestions
Rendering of reflection, refraction, bumpmaps and transparency
Remember exposure/gamma correction
Use camera angles that won't get so many intersections, to speed up the rendering. Eg. isometric (orthagonal = no perspective the rays are parallel) 
Settings to change the graphics: resolution, auto-config, polygon-net, antialiasing, number of reflections, tracks (traces of last rendering) 
Users should be able to draw balls. This will be done in one plane. The rotation of the camera decides if it's parallel to x,y orr z. Scrollwheel changes the distance from the player. The nearest nine grids in the plane is drawn (transparent) to show where the balls will be drawn.
More players can jump in to a started game.
Create objects of spheres that is connected by different couplings: different strength, different elasticity, different directions and movement restrictions. The coupling should be a list of it's own
Light intensity can be returned in every ray to use for bloom, lensflare, illumination thats cached in some grid structure aso
Light source should be a sphere
Light intensity for different places can be cached in some grid structure, för att få en lämplig ljusnivå på spheres på olika ställen
Bloom kan läggas till med kombination av ljusstyrka och _vertices-info
Detaljnivå kan skickas med för varje ray för att avgöra hur djupt man ska gå med reflections osv. lägsta nivån kan vara att bara intersecta griden och returnera mix av färger från innehållet i griden
Antialiasing med lite utveckling av _vertices (position på skärmen), just nu är _vertices lagda i spiral från centrum på skärmen (det utgår från att fokus i centrum ska ritas ut med mest detaljer)
Det går att hoppa över beräkningen av vissa punkter och låta de bestämmas av antialiasing
Eftersläpa färger genom att blanda med senaste färg (ska använda rörelsen från senaste center ray för att kolla hur mycket som ska komma från den gamla färgen)
Flytta punkten (triangeln) för varje frame med random ändring, så att olika punkter renderas 
Use more than one grid and different sizes of the cubes
Fisheye distortion can be solved by not using constant angle in the camera (higher angles in the middle). Tried with sine, root and log but nothing good so far. 
Add cache of rendering by using same technic as spheretexture

Resolved
X Fixed!: Don't create new objects for intersections, reuse or change to structs
X Fixed!: Textures
X Fixed!: Fix unittestings and use them to find the bugs
X Fixed!: Correct the error in the antisphere. When your inside both antisphere and the sphere, you see the inside of the sphere or antisphere
X Render negative objects (cancels intersections)
X Nope only use spheres: [Render cubes]
X Resolved, bilinear interpolation clamps at the edge of the texture. It could be fixed with a wrap-around. [Skybox: Skysphere finished! SkyHemisphere has a problem when looking straight up (same in skySphere) + it's upside down (but my texture was upside down too...)]
X Fixed [Show FPS]
X Fixed adding TrueTypeSharp: [Some type of font (TrueTypeSharp!), maybe drawing own fonts is a solution to fix the issue with 64-bit resourcefiles, can be drawn with spheres (more likely to use the line drawing I looked at before)]
X Changed it: [Ray should be struct or reused to not trigger gc]
X NOPE, this is implemented in the normal playerCommand [gameCommand to check escape or fullscreen?]
X YEP, its ok at this point: [Continue to finish the inputhandler]
X OK: [IPlayerCommand should be struct to not trigger GC]
X YEP, it is actually never placed. Now the last points are saved for reference by the next layer [Remove the triangles placed outside the screen by TriangleProjectionGrid (do not remove, use boundarycheck and save last points for reuse in the next layer)]
X Fixed with pitch and rotation!: [Every rotation in there own transform, didn't resolve the problem. Check values if negative or not. Don't use the saved angles, use a Matrix that saves the rotation.] [Correct the gimballock-distortion]
X Fixed error with the modulus value of the GetInnerPoint() function: [There is a bug with the triangles (it can be seen to the right of the centre line, easiest to see in the yellow balls)]
X Fixed!: [Setting for FOV (send the screen max width and height for the polygon net in to the camera?)]
X Fixed by Parallel.For: [Threading for intersections. Number of threads = cores - 1 (- 1 because main needs one too)]
