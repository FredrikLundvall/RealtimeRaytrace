Up, Right and Backward are the positive directions in Matrix and Vector. Up is +Y, Right is +X and Backward is +Z
Down, Left and Forward are the negative directions in Matrix and Vector. Down is -Y, Left is -X and Forward is -Z

General guidelines
Focus on hiding the inner workings of the different parts for the caller. It's good if it's open and possible to change parts in the middle whether it's for speed or change the design. 
Eg. The raytracing should not know how the pixels are drawn. 
Do not care about the performance, optimization is at a much later stage (with a possible exception of threading issues, that can be good to still consider). 
Interfaces are great for keeping loose couplings in the code.
Don't forget the unit tests, they are great tools while developing.
Be aware of the garbage collections. Try to not create new objects. Reuse objects or use records.

Priority list
x Removed Color from Entity, replaced with new ITextureMap for solid color, SolidColorMap
x Changed input handling to involve the EventMessageQueue (CommandQueue is not used any more) 
1. Now it is time to branch out and focus on an actual game concept:
Concept A:
   local 1 vs 1 or local co-op vs computer placed in space. 
   Background is pre rendered
   Movable spheres.
   Spheres can have any positions (the voxel boundaries should not clip them).
   Simplistic characters (groups of spheres).


Concept B:
   local 1 vs 1 battle game. 
   Background is pre rendered
   x Side-viewed. 
   x Inmovable camera.
   Movable spheres.
   Spheres can have any positions (the voxel boundaries should not clip them).
   Simplistic characters (groups of spheres).
   Physics from box2d library. 
   x Make a thin z-layer, 1 - 10 voxels deep.

Known issues
No mipmapping/cache of the textures    
x That was correct! CommandQueue may be the reason for the gc every ten seconds
Add possibility fo spheres to exist in multiple grids, it's only cube/sphere intersection that's missing

Optimization
GetColorInSky(Vector3 direction) with direction from the ray spawned by the x and y from the TriangleProjectionGrid can be cached (both the rays and the result from UV-calculations) 

Suggestions
Rendering of reflection, refraction, bumpmaps and transparency
Remember exposure/gamma correction
Use camera angles that won't get so many intersections, to speed up the rendering. Eg. isometric (orthagonal = no perspective the rays are parallel) 
Settings to change the graphics: resolution, auto-config, polygon-net, antialiasing, number of reflections, tracks (traces of last rendering) 
Users should be able to draw spheres. This will be done in one plane. The rotation of the camera decides if it's parallel to x,y orr z. Scrollwheel changes the distance from the player. The nearest nine grids in the plane is drawn (transparent) to show where the balls will be drawn.
More players can jump in to a started game.
Create objects of spheres that is connected by different couplings: different strength, different elasticity, different directions and movement restrictions. The coupling should be a list of it's own
Light intensity can be returned in every ray to use for bloom, lensflare, illumination thats cached in some grid structure aso
Light source should be a sphere
Light intensity for different places can be cached in some grid structure, för att få en lämplig ljusnivå på spheres på olika ställen
Bloom can be added by combining light intensity and _vertices-info
Detail level can be submitted with each ray to resolve what render quality to use or how many reflections that should be calculated aso. lägsta nivån kan vara att bara intersecta griden och returnera mix av färger från innehållet i griden
Antialiasing skip tracing some points and let the antialiasing set the color
Cache the color and blend with the new one (can use the movement of the camera to deside the amount of blending to use from the cache)
Move the point (triangels) each frame with some random distance, so different rays are rendered 
Use more than one grid and different sizes of the cubes
Fisheye distortion can be solved by not using constant angle in the camera (higher angles in the middle). Tried with sine, root and log but nothing good so far. 
Add cache of rendering by using same technic as spheretexture

Resolved
X Boundingbox added: [Find the first intersection with the ray/grid before starting the voxel traverse]
X Fixed!: Don't create new objects for intersections, reuse or change to structs
X Fixed!: Textures
X Fixed!: Fix unittestings and use them to find the bugs
X Fixed!: Correct the error in the antisphere. When your inside both antisphere and the sphere, you see the inside of the sphere or antisphere
X Render negative objects (cancels intersections)
X Nope only use spheres: [Render cubes]
X Resolved, bilinear interpolation clamps at the edge of the texture. It could be fixed with a wrap-around. [Skybox: Skysphere finished! SkyHemisphere has a problem when looking straight up (same in skySphere) + it's upside down (but my texture was upside down too...)]
X Fixed [Show FPS]
X Fixed adding TrueTypeSharp: [Some type of font (TrueTypeSharp!), maybe drawing own fonts is a solution to fix the issue with 64-bit resourcefiles, can be drawn with spheres (more likely to use the line drawing I looked at before)]
X Changed it: [Ray should be struct or reused to not trigger gc]
X NOPE, this is implemented in the normal playerCommand [gameCommand to check escape or fullscreen?]
X YEP, its ok at this point: [Continue to finish the inputhandler]
X OK: [IPlayerCommand should be struct to not trigger GC]
X YEP, it is actually never placed. Now the last points are saved for reference by the next layer [Remove the triangles placed outside the screen by TriangleProjectionGrid (do not remove, use boundarycheck and save last points for reuse in the next layer)]
X Fixed with pitch and rotation!: [Every rotation in there own transform, didn't resolve the problem. Check values if negative or not. Don't use the saved angles, use a Matrix that saves the rotation.] [Correct the gimballock-distortion]
X Fixed error with the modulus value of the GetInnerPoint() function: [There is a bug with the triangles (it can be seen to the right of the centre line, easiest to see in the yellow balls)]
X Fixed!: [Setting for FOV (send the screen max width and height for the polygon net in to the camera?)]
X Fixed by Parallel.For: [Threading for intersections. Number of threads = cores - 1 (- 1 because main needs one too)]
